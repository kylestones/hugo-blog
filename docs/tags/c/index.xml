<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>C on Org Mode</title>
    <link>https://kylestones.github.io/hugo-blog/tags/c/</link>
    <description>Recent content in C on Org Mode</description>
    <image>
      <url>https://kylestones.github.io/hugo-blog/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://kylestones.github.io/hugo-blog/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="https://kylestones.github.io/hugo-blog/tags/c/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Advanced Programming in the UNIX Environment</title>
      <link>https://kylestones.github.io/hugo-blog/blog/apue/apue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kylestones.github.io/hugo-blog/blog/apue/apue/</guid>
      <description>I/O  文件 I/O   通过文件描述符标识。对于内核而言，所有打开文件都通过文件描述符引用。 其也是有缓冲的，只是其缓冲区在内核空间，不再用户空间。体现在延迟写，只在适当的时候才调用写文件操作， 减少不必要的写操作，增加性能。 函数 open() 打开文件时，指定模式必须有且仅有 O _RDONLY / O _WRONLY / O _RDWR 三者中的一个。 选项 O _APPEND 指定为追加。原来的 UNIX 系统不支持追加，只能先使用 lseek() 先设置文件的偏移量到文件的 结尾，然后再写。但是这在多个进程同时写的时候会出问题，因为调用了两个函数来追加，所以不是一个原子操作。 而追加选项确保设置偏移和写操作为原子操作。 管道读写   写管道的时候不用使用追加选项，内核会自动按写的顺序写入管道。读取后自动将相应的内容从管道清除。 读取一个写端关闭的管道，在读取完全部数据后，read 函数返回 0 ； 写一个读端关闭的管道，产生 SIGPIPE 信号，设置该信号处理函数或者忽略该信号，write 返回 -1，且 errno 设置为 EPIPE。 读管道，如果管道为空，调用线程阻塞，同进程内的其他线程不受影响。 套接字描述符   虽然套接字描述符本质上是一个文件描述符，但不是所有参数为文件描述符的函数都可以接受套接字描述符。 套接字不支持文件偏移量概念，不能使用 lseek 函数，也不可以使用 mmap 函数，不可调用 fchdir 函数。  shutdown 函数可以直接关闭一个套接字的读端或者写端，不管该套接字描述符复制了多少分； close 函数只有在关闭最后一个套接字的时候才会释放该套接字。 改变文件偏移量   lseek 标准库 I/O   标准 I/O 库的操作围绕流(stream)进行。利用指向 FILE 对象维护，该结构体包含了标准 I/O 库为了维护该流所 需要的信息：文件描述符，指向缓冲区的指针，缓冲区的长度，缓冲区中当前的字符数，出错标志等。不需要关心 FILE 结构的具体形式。 相对于文件 I/O，标准库的 I/O 都是带缓冲的，标准库维护了一个缓冲区，在适当的时候才调用 read、write 函 数，从而减少系统调用的开销。 定位流   ftell、fseek、ftello、fseek、fgetpos、fsetpos IPC   IPC 传统上是 UNIX 中一个杂乱不堪的领域，虽然有了各种各样的解决办法，但没有一个是完美的。可分为四个主 要领域：    消息传递 : 管道、FIFO、消息队列    同步 : 互斥锁、条件变量、读写锁、信号量    共享内存区 : 匿名共享内存区、命令共享内存区    过程调用 : Solaris 门、Sun RPC    包括单个进程内多个线程的 IPC 和多个进程间的 IPC 。 消息边界  无边界   管道和 FIFO 是字节流，没有消息边界； TCP 没有记录边界的字节流； 有边界   POSIX 消息和 System V 消息有从发送者向接收者维护的边界； UDP 提供具有边界记录的消息； 窥探能力  可以窥探   socket recv、recvfrom 函数可以使用标志 MSG _PEEK 从接收队列读取数据，且系统不在读取之后丢弃这些数据； 不可窥探   管道、FIFO、POSIX 消息、System V 消息 只有一个副本递交到一个线程，且消息不能广播或多播到多个接收者（UDP 广播、多播） 读取顺序  先进先出   管道、FIFO 优先级最高的最早消息   POSIX 消息 指定优先级的消息   System V 消息 对象持续性  随进程持续 process-persistent   IPC 对象一直存在到打开着该对象的最后一个进程关闭该对象为止。没有 unlink 函数。 管道、FIFO、POSIX 互斥锁、POSIX 条件变量、POSIX 读写锁、POSIX 基于内存的信号量、fcntl 记录锁、TCP 套 接字、UDP 套接字、Unix 域套接字 随内核持续 kernel-persistent   一直存在到内核重新自举或显示删除该 IPC 对象。存在对应的 unlink 函数。 POSIX 消息队列、POSIX 有名信号量、POSIX 共享内存区、System V 消息队列、System V 信号量、System V 共 享内存 随文件系统持续 filesystem-persistent   一直存在到显示删除该 IPC 对象为止。 IPC 的一个基本设计目标是高性能，而具备随文件系统的持续性可能会使其性能降级，而且进程不可能跨越自举继 续存活。 名字空间 – name space   一种给定的 IPC 类型，其可能名字的集合称为名字空间。名字空间非常重要，因为名字是客户与服务器彼此连接 以交换消息的手段。    IPC 类型 打开或创建 IPC 的名字空间 IPC 打开后的标识     管道 NA 描述符   FIFO 路径名 描述符   POSIX 互斥锁 NA pthread _mutex _t 指针   POSIX 条件变量 NA pthread _cond _t 指针   POSIX 读写锁 NA pthread _rwlock _t 指针   fcntl 记录上锁 路径名 描述符   POSIX 消息队列 POSIX IPC 名字 mqd _t 值   POSIX 命名信号量 POSIX IPC 名字 sem _t 指针   POSIX 共享内存 POSIX IPC 名字 描述符   POSIX 基于内存的信号量 NA sem _t 指针   TCP 套接字 IP 地址与 TCP 端口 描述符   UDP 套接字 IP 地址与 UDP 端口 描述符   Unix 域套接字 路径名 描述符   Sun RPC 程序/版本 RPC 句柄   门 路径名 描述符   System V 消息队列 key _t 键 System V IPC 标识符   System V 信号量 key _t 键 System V IPC 标识符   System V 共享内存 key _t 键 System V IPC 标识符    打开 IPC 名字空间  无名 IPC   管道、POSIX 互斥锁、POSIX 条件变量、POSIX 读写锁、POSIX 基于内存的信号量； 无名 IPC 也可为进程所共享   互斥锁、条件变量、读写锁、POSIX 无名信号量都是无名的，也就是说他们是基于内存的。他们很容易为单个进程 内的不同线程所共享；当他们存放在不同进程间所共享的内存区中时，同时设置其进程共享属性，也可以为这些进 程所共享。 打开路径名 (path) 来打开 IPC   FIFO、fcntl、Unix 域套接字、门； 打开 POSIX IPC 名字来打开 IPC   POSIX 消息队列、POSIX 命令信号量、POSIX 共享内存； 基于 IP 地址和端口号来打开 IPC   TCP 套接字、UDP 套接字； 基于 key _t 键打开 IPC   System V 消息队列、System V 信号量、System V 共享内存； 打开 IPC 后的标识  描述符   管道、FIFO、fcntl、POSIX 共享内存、TCP 套接字、UDP 套接字、Unix 虞域套接字、门 相应形式的指针     POSIX 互斥锁    POSIX 条件变量    POSIX 读写锁    POSIX 命名信号量    POSIX 基于内存的信号量   值     POSIX 消息队列   System V IPC 标识符     System V 消息队列    System V 信号量    System V 共享内存   RPC 句柄   Sun RPC 需要定义结构体变量–指针   除了 Posix 信号量需要定义成指针，其他的都需要定义成变量。 结构体   互斥锁、条件变量、读写锁、Posix 无名信号量、Posix 消息队列、 描述符、Posix 共享内存、 指针   Posix 命名信号量、mmap、 fork、exec、exit 对 IPC 的影响     无名同步变量（互斥锁、条件变量、读写锁、基于内存的信号量），从一个具有多线程的进程中调用 fork 将变得 混乱不堪；如果这些变量驻留在共享内存区中，而且创建时设置了进程共享属性，那么对于能访问该共享内存区的 任意进程来说，其任意线程能继续访问这些变量。    System V IPC 的三种形式没有打开或关闭的说法，只需知道其标识符即可访问。      IPC 类型 fork exec _exit     管道、FIFO 子进程取得父进程的所有打开着的文件描述符的副本 所有打开着的文件描述符继续打开，除非设置了 FD _CLOEXEC 位 关闭所有打开着的描述符，最后一个关闭时删除管道或 FIFO 中残留的数据   POSIX 消息队列 子进程取得父进程的所有打开着的消息队列描述符的副本 关闭所有打开着消息队列描述符 关闭所有打开着的消息队列描述符   System V 消息队列 – – –   POSIX 互斥锁和条件变量 若驻留在共享内存区中而且具有进程间共享属性，则共享 除非在继续打开着的共享内存区中而且具有进程间共享属性，否则消失 除非在继续打开着的共享内存区中而且具有进程间共享属性，否则消失   POSIX 读写锁 若驻留在共享内存区中而且具有进程间共享属性，则共享 除非在继续打开着的共享内存区中而且具有进程间共享属性，否则消失 除非在继续打开着的共享内存区中而且具有进程间共享属性，否则消失   POSIX 基于内存的信号量 若驻留在共享内存区中而且具有进程间共享属性，则共享 除非在继续打开着的共享内存区中而且具有进程间共享属性，否则消失 除非在继续打开着的共享内存区中而且具有进程间共享属性，否则消失   POSIX 命名信号量 父进程中所有打开着的命名信号量在子进程中继续打开着 关闭所有打开着的命名信号量 关闭所有打开着的命名信号量   fcntl 记录锁 子进程不继承父进程持有的锁 只要描述符继续打开着，锁就不变 解开由进程持有的所有未处理的锁   System V 信号量 子进程中所有 semadj 值都置位 0 所有 semadj 值都携入新进程 所有 semadj 值都加到相应的信号量值上   mmap 内存映射 父进程的内存映射存留到子进程中 去除内存映射 去除内存映射   POSIX 共享内存区 父进程中内存映射存留到子进程中 去除内存映射 去除内存映射   System V 共享内存区 附接着的共享内存区在子进程中继续附接着 断开所有附接着的共享内存区 断开所有附接着的共享内存区   门 子进程取得父进程的所有打开着的描述符，但是客户在门描述符上激活其过程时，只有父进程是服务器 所有门描述符都应关闭，因为它们创建时设置了 FD _CLOEXEC 位 关闭所有打开着的描述符    锁释放  内核自动释放   持有某个锁的进程没有释放就终止，内核自动释放该锁； fcntl 记录锁、System V 信号量（可选项） 无法释放锁   互斥锁、条件变量、读写锁、POSIX 信号量 进程、线程与共享信息   没有任何东西限制任何 IPC 技术只适用于两个进程。    两个进程共享存留于文件系统中某个文件上的某些信息。为了访问这些信息，每个进程都得穿越内核（例如 read、write、lssk 等）；需要某种形式的同步，如记录锁。    两个进程共享驻留于内核的某些信息，访问共享信息的每次操作都涉及对内核的一次系统调用。管道、 System V 消息队列、System V 信号量均是；    两个进程有一个双方都能访问的共享存储区，需要某种形式的同步（信号量等）。每个进程一旦设置好该共享 内存区，就能根本不涉及内核而访问其中的数据。   进程 – 线程  设计线程的原因：     fork 的开销很大。内存映射要从父进程复制到子进程，所有描述符要在子进程复制一份。尽管存在写时复制 (copy-on-write) 的技术，fork 的开销仍然很大。    fork 子进程后，需要使用 IPC 在父子进程之间传递信息。   线程共享全局内存空间   一个进程内的所有线程共享同一个全局内存空间。使得线程间很容易共享信息，但这种易用性也带来了同步 (synchronization) 问题。 线程共享的资源     全局内存空间    进程指令    打开的文件    信号处理程序和信号处置    当前工作目录    用户 ID 和 组 ID   线程私有资源     线程 ID    寄存器集合，包括程序计数器和栈指针    栈，存放局部变量和返回地址    errno    信号掩码    优先级   系统开销     执行一般命令 1ns = 1/1,000,000,000s   从 L1 级缓存读 0.</description>
    </item>
    
    <item>
      <title>C Traps and Pitfalls</title>
      <link>https://kylestones.github.io/hugo-blog/blog/apue/c-traps-and-pitfalls/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kylestones.github.io/hugo-blog/blog/apue/c-traps-and-pitfalls/</guid>
      <description>导读   程序严格按照我们写明的程序来执行，但结果却并不是我们真正希望得到的。 程序设计错误实际上反应的是程序与程序员的“心智模式”两者的相异之处。（心智模式(mental model)解释为人 们深植心中，对于周遭世界如何运作的看法和行为；《列子》中记录有疑邻盗斧） 练习  0-1 返修率高   你是否愿意购买一个返修率很高的厂商所生产的汽车？如果厂家声明它已经做出了改进，你的态度是否会改变？用 户为你找出程序中的 Bug，你真正损失的是什么？  答：我们经常会依据厂商的信誉去购买其商品；会考虑其最近的高质量是真实的还是偶然的；会损失信誉。而信誉 一旦失去，就很难重新获得。 0-2 修建一个 100 英尺长的护栏，护栏的栏杆之间相距 10 英尺，共需要多少根栏杆？   答：11 根。 0-3 菜刀   在烹饪时你是否失手用菜刀切伤过自己的手？怎样改进菜刀使得使用更安全？你是否愿意使用这样一把经过改良的 菜刀？  答：我们很容易想到办法让一个工具更安全，代价是原来简单的工具现在要变得复杂一些。食品加工机一般有连锁 装置，保护使用者不让手指受伤。但是菜刀却不同，给这样一个简单、灵活的工具附加保护手指避免受伤的装置， 只能让其失去简单灵活的特点。实际上，这样做最后得到的也许更像一台食品加工机，而不是一把菜刀。 使其难于做“傻事”常常会使其难于做“聪明事”，正所谓“弄巧成拙”。 第 1 章 词法陷阱   从较低层面考虑，程序是由 符号(token) 序列组成的，将程序分解成符号的过程称为“词法分析” 术语符号指的是程序的一个基本组成单元，其作用相当于一个句子中的单词，在不同的句子中用于相同的意义；但 是组成符号的字符序列就不同，同一组字符序列在某个上下文环境中属于一个符号，而在另一个上下文环境中可能 属于完全不同的另一个符号。 编译器中负责将程序分解为一个一个符号的部分称为“词法分析器” 在 C 语言中，符号之间的空白（包括空格符、制表符或换行符）将被忽略，因此 C 语言书写的格式可以很随意， 但这并不是好习惯。 1.1 = is not ==   C 语言中赋值符号被作为一种操作符对待，因而重复进行赋值操作可以很容易的书写(a=b=c) 不要误用比较运算和赋值运算    比较运算时，如果有常量，将常量方在左侧    如果确实需要赋值运算，明确的表示出来，如下：   if(x = y) foo(); //应写成 if (0 !</description>
    </item>
    
    <item>
      <title>Funny of C</title>
      <link>https://kylestones.github.io/hugo-blog/blog/apue/fun-of-c/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kylestones.github.io/hugo-blog/blog/apue/fun-of-c/</guid>
      <description>变量   所谓变量，其实是内存地址的一个抽像名字罢了;;  在静态编译的程序中，所有的变量名都会在编译时被转成内存地址。机器是不知道我们取的名字的，只知道地址。  不管结构体的实例是什么– 访问其成员其实就是加成员的偏移量。 宏定义   C 语言的宏实现对组成程序的字符进行变换的方式。宏既可以使一段看上去完全不合语法的代码成为一个有效的 C 程序，也能使一段看上去无害的代码成为一个可怕的怪物。比如可以阅读陈皓的 《6 个变态的 C 语言 Hello World 程序》 #define tString(x) #x // 传入参数两侧加上双引号&amp;#34; 。如果入参是变量，其定义必须在宏定义之前 #define toChar(x) #@x // 将参数两侧加上单引号&amp;#39; ， #define conn(x,y) x##y // 连接两个参数  字符串  数组     C 语言中只有一维数组，而且数组的大小必须在编译期就作为常数确定下来。但数组中的元素可以是任何类型 的对象，当然也就可以是另外一个数组    对一个数组只能做两件事：确定数组的大小；获得指向数组下标为 0 的元素的指针。    任何一个数组下标运算都等同于一个对应的指针运算。  对于数组 char s[10]来说，数组名 s 和 &amp;amp;s 都是一样的。 int a[10]; int i = 3; *a = 84; *(a+i) = 22; a[i] = 21; /* 表达式 *(a+i) 即数组 a 中下标为 i 的元素的引用；由于比较常用，所以被简记成 a[i] ； * 又由于 a+i 与 i+a 含义相同，因此 *(a+i) 与 *(i+a) 含义相同，所以 a[i] 与 i[a] 含义相同 */ i[a] = 12; //虽然如此，但强烈不建议这么写   数组的原地就是内容，长度为 0 的数组其并不占据内存。 指针  链表  #include &amp;lt;stdlib.</description>
    </item>
    
  </channel>
</rss>
